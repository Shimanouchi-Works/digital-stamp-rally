@page
@model DigitalStampRally.Pages.Test.StampLoadTestModel
@{
    ViewData["Title"] = "スタンプ負荷テスト";
}

<div class="container py-4" style="max-width:900px;">
    <h1 class="h4 fw-bold mb-4">スタンプ疑似押下テスト</h1>

    <div class="card shadow-sm">
        <div class="card-body">

            <div class="mb-3">
                <label class="form-label">イベントID</label>
                <input id="eventId" type="number" class="form-control" />
            </div>

            <div class="mb-3">
                <label class="form-label">ユーザー数</label>
                <input id="userCount" type="number" class="form-control" />
            </div>

            <div class="mb-3">
                <label class="form-label">ゴール人数</label>
                <input id="goalCount" type="number" class="form-control" value="0" min="0" />
                <div class="form-text">0ならゴール送信なし。ユーザー数を超える場合はユーザー数に丸めます。</div>
            </div>

            <button id="btnStart" class="btn btn-danger" onclick="startTest()">
                スタート
            </button>

            <div class="mt-3">
                <div class="small text-muted" id="meta"></div>
                <div class="small" id="result"></div>
            </div>

        </div>
    </div>
</div>

@section Scripts{
<script>

const CONCURRENCY = 20; // ← 好きな数に。上げすぎ注意

function randomDate(start, end) {
    const startMs = start.getTime();
    const endMs = end.getTime();
    const randomMs = startMs + Math.random() * (endMs - startMs);
    return new Date(randomMs);
}

async function runPool(tasks, concurrency) {
    let i = 0;
    const workers = Array.from({ length: concurrency }, async () => {
        while (i < tasks.length) {
            const taskIndex = i++;
            await tasks[taskIndex]();
        }
    });
    await Promise.all(workers);
}

function generateToken() {
    let token;
    if (window.crypto && crypto.getRandomValues) {
        const buf = new Uint8Array(16);
        crypto.getRandomValues(buf);
        token = [...buf].map(b => b.toString(16).padStart(2, '0')).join('');
    }else{
        token = 't-' + Date.now() + '-' + Math.random().toString(36).substring(2);
    }

    console.log(`token:${token}`);
    // fallback
    return token;
}

async function startTest() {
    const btn = document.getElementById("btnStart");
    btn.disabled = true;

    try {
        const eventId = parseInt(document.getElementById("eventId").value);
        const userCount = parseInt(document.getElementById("userCount").value);
        const goalCountRaw = parseInt(document.getElementById("goalCount").value ?? "0");
        const goalCount = Math.max(0, Math.min(userCount, isNaN(goalCountRaw) ? 0 : goalCountRaw));

        if (!eventId || !userCount) {
            alert("イベントIDとユーザー数を入力してください");
            return;
        }

        document.getElementById("result").innerText = "";
        document.getElementById("meta").innerText = "DBからイベント情報・スポット一覧を取得中…";

        // ① DBからメタ情報取得（有効期限＆スポットID一覧）
        const metaRes = await fetch(`?handler=Meta&eventId=${eventId}`, { method: "GET" });
        if (!metaRes.ok) {
            const txt = await metaRes.text();
            throw new Error(`Meta取得に失敗: ${txt}`);
        }

        const meta = await metaRes.json();
        const startsAt = new Date(meta.startsAt);
        const endsAt = new Date(meta.endsAt);
        const spots = meta.spots; // number[]

        document.getElementById("meta").innerText =
            `有効期限: ${meta.startsAt} ～ ${meta.endsAt} / スポット数: ${spots.length}`;

        if (!spots || spots.length === 0) {
            throw new Error("スポットが0件です（DBにスポットがありません）");
        }
        if (startsAt >= endsAt) {
            throw new Error("開始日時と終了日時が不正です（開始 >= 終了）");
        }

        const USER_CONCURRENCY = 10;  // ユーザーを同時に処理する数（まずは10）
        const STAMP_CONCURRENCY = 10; // 1ユーザー内のスタンプ同時送信数（まずは10）

        let okCalls = 0;
        let failCalls = 0;

        // 1ユーザー分を「スタンプ完了→（必要なら）ゴール」までやる
        async function runOneUser(u) {
            const visitorId = generateVisitorId();

            // ① スタンプ（順序保証のため、"このユーザーのスタンプ" が全部終わるまで待つ）
            const stampTasks = spots.map(spot => async () => {
                const dt = randomDate(startsAt, endsAt).toISOString();

                const body = {
                    EventId: eventId,
                    SpotId: spot.id,     // spotsが {id:...} の前提
                    Token: generateToken(),
                    VisitorId: visitorId
                };

                const r = await fetch(`/App/ReadStamp?handler=Stamp&date=${encodeURIComponent(dt)}`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body)
                });

                if (!r.ok) {
                    failCalls++;
                    const t = await r.text();
                    throw new Error(`Stamp失敗 event=${eventId} spot=${spot.id}: ${t}`);
                }
                okCalls++;
            });

            // このユーザーのスタンプを並列で実行（STAMP_CONCURRENCYで制限）
            await runPool(stampTasks, STAMP_CONCURRENCY);

            // ② ゴール（この時点でスタンプが全て完了していることが保証される）
            if (u < goalCount) {
                const goalDt = randomDate(startsAt, endsAt).toISOString();

                const gr = await fetch(`/App/SetGoal?handler=Goal&date=${encodeURIComponent(goalDt)}`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        EventId: eventId,
                        Token: generateToken(),
                        VisitorId: visitorId
                    })
                });

                if (!gr.ok) {
                    failCalls++;
                    const t = await gr.text();
                    throw new Error(`Goal失敗 event=${eventId}: ${t}`);
                }
                okCalls++;
            }
        }

        // ユーザー単位で並列実行（USER_CONCURRENCYで制限）
        const userTasks = Array.from({ length: userCount }, (_, u) => async () => {
            await runOneUser(u);
        });

        document.getElementById("meta").innerText =
        `送信開始…（ユーザー=${userCount}, ゴール=${goalCount}, スポット=${spots.length}, ユーザー並列=${USER_CONCURRENCY}, スタンプ並列=${STAMP_CONCURRENCY}）`;

        await runPool(userTasks, USER_CONCURRENCY);

        document.getElementById("result").innerText =
        `完了：成功=${okCalls}, 失敗=${failCalls}`;


        @* for (let u = 0; u < userCount; u++) {
            const visitorId = generateVisitorId();

            for (const spot of spots) {
                const dt = randomDate(startsAt, endsAt).toISOString();

                // NOTE: Tokenはテスト用固定。Stamp API側でテスト時は許可するようにします。
                const body = {
                    EventId: eventId,
                    SpotId: spot.id,
                    Token: "TEST_TOKEN",
                    VisitorId: visitorId
                };

                const r = await fetch(`/App/ReadStamp?handler=Stamp&date=${encodeURIComponent(dt)}`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body)
                });

                if (!r.ok) {
                    const t = await r.text();
                    throw new Error(`Stamp失敗 event=${eventId} spot=${spotId}: ${t}`);
                }

                totalCalls++;
            }

            if (u < goalCount) {
                const goalDt = randomDate(startsAt, endsAt).toISOString();

                const gr = await fetch(`/App/SetGoal?handler=Goal&date=${encodeURIComponent(goalDt)}`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        EventId: eventId,
                        Token: "TEST_TOKEN",
                        VisitorId: visitorId
                    })
                });

                if (!gr.ok) {
                    const t = await gr.text();
                    throw new Error(`Goal失敗 event=${eventId}: ${t}`);
                }

                totalCalls++;
            }
        } *@

        @* document.getElementById("result").innerText =
        `完了：${totalCalls} 件送信（ユーザー=${userCount}, ゴール=${goalCount}, スポット=${spots.length}）`; *@

    } catch (e) {
        document.getElementById("result").innerText = `エラー：${e.message ?? e}`;
    } finally {
        btn.disabled = false;
    }
}

function generateVisitorId() {
    let id;
    // cryptoが使える場合
    if (window.crypto && crypto.getRandomValues) {
        const buf = new Uint8Array(16);
        crypto.getRandomValues(buf);

        // RFC4122 v4っぽく整形
        buf[6] = (buf[6] & 0x0f) | 0x40;
        buf[8] = (buf[8] & 0x3f) | 0x80;

        const hex = [...buf].map(b => b.toString(16).padStart(2, '0')).join('');

        id = `${hex.substring(0,8)}-${hex.substring(8,12)}-${hex.substring(12,16)}-${hex.substring(16,20)}-${hex.substring(20)}`;
    }else{
        id = 'v-' + Date.now() + '-' + Math.floor(Math.random() * 1000000);
    }

    // fallback（超簡易）
    console.log(`id:${id}`);
    return id;
}

</script>
}
