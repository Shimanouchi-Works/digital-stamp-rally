@page
@model DigitalStampRally.Pages.CreateNewModel
@using System.Text.Json
@{
    ViewData["Title"] = "新しいスタンプラリーを作成";
}

<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/ja.js"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/plugins/confirmDate/confirmDate.js"></script>


<div class="container py-4">
    <div class="mb-4">
        <h1 class="h3 fw-bold">新しいスタンプラリーを作成</h1>
        <p class="text-muted mb-0">イベント情報と掲示場所を入力してください。</p>
    </div>

    @if (!string.IsNullOrWhiteSpace(Model.ErrorMessage))
    {
        <div class="alert alert-danger" role="alert">@Model.ErrorMessage</div>
    }

    <form method="post" enctype="multipart/form-data" asp-page-handler="Generate">
        <div class="card shadow-sm mb-3">
            <div class="card-body">
                <h2 class="h5 fw-bold mb-3">イベント基本情報</h2>

                <div class="mb-3">
                    <label class="form-label">行事タイトル</label>
                    <input class="form-control" asp-for="Input.EventTitle" maxlength="80" required />
                    <span class="text-danger small" asp-validation-for="Input.EventTitle"></span>
                </div>

                <div class="mb-3">
                    <label class="form-label">イベント画像（任意）</label>
                    <input
                        id="eventImageInput"
                        class="form-control"
                        type="file"
                        asp-for="Input.EventImageFile"
                        accept="image/*" />
                    @* <div class="form-text">PDFに掲載されます。</div> *@
                    <span class="text-danger small" asp-validation-for="Input.EventImageFile"></span>

                    <!-- ★プレビュー領域（新規選択でも復元でもOK） -->
                    <div id="eventImagePreviewWrap"
                        class="mt-2"
                        style="display:none;"
                        data-loaded-ct="@(Model.Input.LoadedEventImage?.ContentType ?? "")"
                        data-loaded-b64="@(Model.Input.LoadedEventImage?.Base64 ?? "")"
                        data-loaded-name="@(Model.Input.LoadedEventImage?.FileName ?? "")">
                        <div id="eventImagePreviewCaption" class="small text-muted mb-1"></div>

                        <img id="eventImagePreview"
                            class="img-thumbnail"
                            style="max-height: 140px; width: auto;"
                            alt="イベント画像プレビュー" />
                    </div>
                </div>

                <div class="row g-3">
                    <div class="col-12 col-lg-6">
                        <label class="form-label">QRコード有効期間 <span style="font-size:0.85em;">-開始-</span></label>
                        @* <input
                            class="form-control"
                            asp-for="Input.ValidFrom"
                            min="@Model.Input.ValidFromMin"
                            max="@Model.Input.ValidFromMax"
                            type="datetime-local"
                            step="300"
                            required /> *@
                        <input class="form-control js-dtp"
                            asp-for="Input.ValidFrom"
                            type="text"
                            inputmode="none"
                            autocomplete="off"
                            required />
                        <span class="text-danger small" asp-validation-for="Input.ValidFrom"></span>
                    </div>
                    <div class="col-12 col-lg-6">
                        <label class="form-label">QRコード有効期間 <span style="font-size:0.85em;">-終了-</span></label>
                        @* <input
                            class="form-control"
                            asp-for="Input.ValidTo"
                            min="@Model.Input.ValidToMin"
                            max="@Model.Input.ValidToMax"
                            type="datetime-local"
                            step="300"
                            required /> *@
                        <input class="form-control js-dtp"
                            asp-for="Input.ValidTo"
                            type="text"
                            inputmode="none"
                            autocomplete="off"
                            required />
                        <span class="text-danger small" asp-validation-for="Input.ValidTo"></span>
                    </div>
                    <div id="dateRangeError" class="text-danger small mt-1" style="display:none;">
                        有効期間（開始）は（終了）より前にしてください。
                    </div>
                </div>

            </div>
        </div>

        <div class="card shadow-sm mb-3">
            <div class="card-body">
                <div class="d-flex align-items-center justify-content-between mb-2">
                    <h2 class="h5 fw-bold mb-0">掲示場所</h2>
                    @* <button type="button" class="btn btn-outline-primary btn-sm" id="btnAddSpot">
                        ＋ 掲示場所を追加
                    </button> *@
                </div>

                <div class="mt-3 small text-muted">
                    @* ゴール達成条件として必須にする掲示場所は、「必須」にチェックしてください。 *@
                    <ul>
                        <li>「必須」にチェックが入っている掲示場所のスタンプを全て集めるとゴール可能になります</li>
                        <li>「必須」にチェックが入っていない掲示場所のスタンプは、ゴール条件には含まれませんが、イベント運営上の演出等に利用できます(追加特典・抽選。お楽しみ要素 など)</li>
                        <li>場所に限らず集めたスタンプの個数でゴールとする場合は、「必須」にはチェックを付けずゴールの際に主催者側で数の確認をしてください</li>
                    </ul>
                </div>

                <div class="table-responsive">
                    <table class="table table-sm align-middle" id="spotTable">
                        <thead>
                            <tr>
                                <th style="width:140px;">
                                    <div class="form-check d-flex align-items-center gap-1">
                                        <input class="form-check-input" type="checkbox" id="chkRequiredAll" />
                                        <label class="form-check-label" for="chkRequiredAll">
                                            必須
                                        </label>
                                    </div>
                                </th>
                                <th>掲示場所名</th>
                                <th style="width:90px;">
                                </th>
                            </tr>
                        </thead>
                        <tbody id="spotTbody">
                        @for (int i = 0; i < Model.Input.Spots.Count; i++)
                        {
                            <tr class="spot-row">
                                <td>
                                    <div class="form-check">
                                        <input class="form-check-input"
                                               type="checkbox"
                                               name="Input.Spots[@i].IsRequired"
                                               id="Input_Spots_@i"
                                               value="true"
                                               @(Model.Input.Spots[i].IsRequired ? "checked" : "") />
                                        <input type="hidden" name="Input.Spots[@i].IsRequired" value="false" />
                                        <label class="form-check-label" for="Input_Spots_@i">必須</label>
                                    </div>
                                </td>
                                <td>
                                    <input class="form-control"
                                           name="Input.Spots[@i].SpotName"
                                           value="@Model.Input.Spots[i].SpotName"
                                           maxlength="60"
                                           required />
                                </td>
                                <td class="text-end">
                                    <button type="button" class="btn btn-outline-danger btn-sm btnRemoveSpot">削除</button>
                                </td>
                            </tr>
                        }
                        </tbody>
                    </table>
                </div>
                <div class="d-flex justify-content-center my-2">
                    <button type="button" class="btn btn-outline-primary btn-sm" id="btnAddSpot">
                        ＋ 掲示場所を追加
                    </button>
                </div>

                <div class="form-text">
                    ※ 最低1件必要です。<br />
                    ※ 掲示場所名は空欄や、他の掲示場所名との重複はできません。
                </div>
            </div>
        </div>

        <div class="d-flex gap-2">
            <button class="btn btn-primary" type="submit" id="btnSubmit" disabled>
                作成する
            </button>
            <a class="btn btn-outline-secondary" href="/App/Index">ホームへ</a>
        </div>

        <input type="hidden" asp-for="Input.LoadToken" />
    </form>
</div>

@section Scripts {
    <partial name="_ValidationScriptsPartial" />

    <script>
        (function () {
            document.addEventListener("DOMContentLoaded", () => {
                const fromMin = @Html.Raw(JsonSerializer.Serialize(Model.Input.ValidFromMin));
                const fromMax = @Html.Raw(JsonSerializer.Serialize(Model.Input.ValidFromMax));
                const toMin   = @Html.Raw(JsonSerializer.Serialize(Model.Input.ValidToMin));
                const toMax   = @Html.Raw(JsonSerializer.Serialize(Model.Input.ValidToMax));

                // flatpickr が読み込まれてなければ何もしない
                if (!window.flatpickr) return;

                const fromEl = document.querySelector('input[name="Input.ValidFrom"]');
                const toEl   = document.querySelector('input[name="Input.ValidTo"]');

                if (!fromEl || !toEl) return;

                const ConfirmPlugin = window.confirmDatePlugin || confirmDatePlugin;
                // ASP.NETのDateTimeバインドに合わせて、送信値を yyyy-MM-ddTHH:mm にする
                const fpBase = {
                    locale: flatpickr.l10ns.ja,
                    enableTime: true,
                    time_24hr: true,
                    minuteIncrement: 5,
                    // サーバー送信用（隠しinputに保持される）
                    dateFormat: "Y-m-d\\TH:i",
                    // 表示用
                    altInput: true,
                    altFormat: "Y/m/d H:i",

                    allowInput: false,
                    disableMobile: true,

                    plugins: [
                        new ConfirmPlugin({
                            confirmText: "OK",
                            showAlways: true,   // ← まずはtrueで「確実に出す」
                            theme: "light"
                        })
                    ]
                };

                // 既にサーバーが value を入れている場合、それを初期表示に使う
                // 例: 2026-02-11T06:34
                const initialFrom = fromEl.value || null;
                const initialTo   = toEl.value || null;

                const fpTo = flatpickr(toEl, {
                ...fpBase,
                defaultDate: initialTo,
                minDate: parseLocal(toMin),
                maxDate: parseLocal(toMax)
                });

                const fpFrom = flatpickr(fromEl, {
                ...fpBase,
                defaultDate: initialFrom,
                minDate: parseLocal(fromMin),
                maxDate: parseLocal(fromMax),
                onChange: function(selectedDates) {
                    if (!selectedDates || selectedDates.length === 0) return;

                    const fromDate = selectedDates[0];

                    // (2) 開始が選ばれたら：終了が開始より過去なら、終了=開始に自動補正
                    const toDate = fpTo.selectedDates && fpTo.selectedDates[0];
                    if (!toDate || toDate < fromDate) {
                    fpTo.setDate(fromDate, true); // true = input値更新 + onChange発火
                    }

                    // 終了の最小値も開始に合わせておく（UI上もミスりにくくなる）
                    fpTo.set("minDate", fromDate);
                }
                });

                // もし初期値がある場合、minDateも合わせておく
                if (fpFrom.selectedDates && fpFrom.selectedDates[0]) {
                fpTo.set("minDate", fpFrom.selectedDates[0]);
                }

                // (3) 開始 > 終了 の場合のエラー表示は、既存の refresh/isValid に統合するのが一番自然。
                // もし専用の表示場所があるならここで切り替えてOKです。
            });
        })();

        function parseLocal(dt) {
            // dt: "2026-02-11T06:34"
            if (!dt) return null;
            // Safari対策： "YYYY-MM-DDTHH:mm" を Date が解釈できない場合があるので分解
            const [d, t] = dt.split("T");
            const [y, m, day] = d.split("-").map(Number);
            const [hh, mm] = t.split(":").map(Number);
            return new Date(y, m - 1, day, hh, mm, 0);
        }

        (function () {
            const MAX_SPOTS = @Model.MaxSpotsForUi; // C#側の定義を反映

            const tbody = document.getElementById('spotTbody');
            const btnAdd = document.getElementById('btnAddSpot');
            const chkAll = document.getElementById('chkRequiredAll'); // ヘッダの一括チェック

            const btnSubmit = document.getElementById("btnSubmit");
            const titleInput = document.querySelector('input[name="Input.EventTitle"]');
            const fromInput = document.querySelector('input[name="Input.ValidFrom"]');
            const toInput   = document.querySelector('input[name="Input.ValidTo"]');
            const dateRangeError = document.getElementById("dateRangeError");

            const input = document.getElementById('eventImageInput');
            const wrap = document.getElementById('eventImagePreviewWrap');
            const img = document.getElementById('eventImagePreview');
            const cap = document.getElementById('eventImagePreviewCaption');

            let globalCheckBoxIndex = @Model.Input.Spots.Count;


            function showPreview(src, caption) {
                img.src = src;
                cap.textContent = caption || "";
                wrap.style.display = "block";
            }

            // 1) 初期表示（復元済み画像があれば表示）
            const loadedB64 = wrap?.dataset?.loadedB64 || "";
            if (loadedB64) {
                const ct = wrap.dataset.loadedCt || "image/*";
                const name = wrap.dataset.loadedName || "event";
                const src = `data:${ct};base64,${loadedB64}`;
                showPreview(src, `現在のイベント画像（復元済み）— ${name}`);
            }

            // 2) 新規選択（ファイルを選んだら即プレビュー）
            if (input) {
                input.addEventListener('change', () => {
                const file = input.files && input.files[0];

                if (!file || !file.type || !file.type.startsWith("image/")) {
                    //alert("画像ファイルを選択してください。");
                    input.value = "";
                    wrap.style.display = "none";
                    img.src = "";
                    cap.textContent = "";
                    return;
                }


                const url = URL.createObjectURL(file);
                showPreview(url, `現在のイベント画像 — ${file.name}`);
                });
            }


            // 行内の「必須」チェック一覧
            function getRowChecks() {
                return tbody.querySelectorAll('input.form-check-input[type="checkbox"]');
            }

            // 行追加/削除後も含め、Input.Spots[i] の i を再採番
            function reindex() {
                const rows = tbody.querySelectorAll('tr.spot-row');
                rows.forEach((row, i) => {
                    const chk = row.querySelector('input.form-check-input[type="checkbox"]');
                    const hid = row.querySelector('input[type="hidden"]');
                    const spot = row.querySelector('input.form-control');

                    // チェックボックスは true を送る
                    chk.name = `Input.Spots[${i}].IsRequired`;

                    // false を送る hidden（チェックされてない時に必要）
                    hid.name = `Input.Spots[${i}].IsRequired`;

                    // 場所名
                    spot.name = `Input.Spots[${i}].SpotName`;
                });

                syncHeaderCheckbox();
            }

            // ヘッダチェックの状態を、行の状態に合わせて同期
            // ルール：全行がONの時だけヘッダON、それ以外はOFF（indeterminateは使わない）
            function syncHeaderCheckbox() {
                const checks = getRowChecks();
                if (!chkAll) return;

                if (checks.length === 0) {
                    chkAll.checked = false;
                    return;
                }
                chkAll.checked = Array.from(checks).every(c => c.checked);
            }

            function updateButtonsState() {
                const rows = tbody.querySelectorAll('tr.spot-row');
                const count = rows.length;

                // 1件しかない場合：削除ボタンを無効化
                rows.forEach(row => {
                    const removeBtn = row.querySelector('.btnRemoveSpot');
                    if (removeBtn) removeBtn.disabled = (count <= 1);
                });

                // 最大件数に達した場合：追加ボタンを無効化
                if (btnAdd) {
                    btnAdd.disabled = (count >= MAX_SPOTS);
                }
            }

            // 行を1つ追加
            function addRow(defaultName = "") {
                const currentCount = tbody.querySelectorAll('tr.spot-row').length;
                if (currentCount >= MAX_SPOTS) return; // ★追加（上限なら何もしない）

                const tr = document.createElement('tr');
                tr.className = 'spot-row';

                tr.innerHTML = `
                    <td>
                        <div class="form-check">
                            <input class="form-check-input" id="Input_Spots_${globalCheckBoxIndex}" type="checkbox" value="true" />
                            <input type="hidden" value="false" />
                            <label class="form-check-label" for="Input_Spots_${globalCheckBoxIndex}">必須</label>
                        </div>
                    </td>
                    <td>
                        <input class="form-control" maxlength="60" required />
                    </td>
                    <td class="text-end">
                        <button type="button" class="btn btn-outline-danger btn-sm btnRemoveSpot">削除</button>
                    </td>
                `;
                globalCheckBoxIndex++;

                tr.querySelector('input.form-control').value = defaultName;
                tbody.appendChild(tr);

                reindex();
                refresh(); // ★追加（即反映）
            }

            function isValid() {
                // 1. タイトル
                if (!titleInput.value.trim()) return false;

                // 2. 日時
                if (!fromInput.value || !toInput.value) return false;
                if (new Date(fromInput.value) >= new Date(toInput.value)) return false;

                // 3. 掲示場所
                const rows = tbody.querySelectorAll("tr.spot-row");
                if (rows.length === 0) return false;

                // ★ 追加：必須が1件以上
                @* const requiredChecks = tbody.querySelectorAll('tr.spot-row input.form-check-input[type="checkbox"]');
                if (!Array.from(requiredChecks).some(c => c.checked)) return false; *@

                const names = [];
                for (const row of rows) {
                    const input = row.querySelector('input.form-control');
                    const name = input.value.trim();
                    if (!name) return false;
                    names.push(name.toLowerCase());
                }

                // 4. 重複チェック
                const unique = new Set(names);
                if (unique.size !== names.length) return false;

                return true;
            }


            function refresh() {
                // 日付エラー表示　<-自動調整するようにしたのでエラー表示はいったんなしに
                @* const hasFrom = !!fromInput.value;
                const hasTo = !!toInput.value;
                const invalidRange = hasFrom && hasTo && (new Date(fromInput.value) > new Date(toInput.value));

                if (dateRangeError) {
                    dateRangeError.style.display = invalidRange ? "block" : "none";
                } *@

                btnSubmit.disabled = !isValid();
                updateButtonsState();
            }

            // ---- イベント登録 ----
            document.addEventListener("input", refresh);
            document.addEventListener("change", refresh);

            // ---- 期限：開始変更で終了を補正 ----
            fromInput.addEventListener("change", () => {
                if (!fromInput.value) return;

                // 終了が空、または開始より過去なら、終了=開始にする
                if (!toInput.value || new Date(toInput.value) < new Date(fromInput.value)) {
                    toInput.value = fromInput.value;
                }
                refresh();
            });
            toInput.addEventListener("change", () => {
                if (!toInput.value) return;

                // 開始が空、または終了より未来なら、開始=終了にする
                if (!fromInput.value || new Date(toInput.value) < new Date(fromInput.value)) {
                    fromInput.value = toInput.value;
                }
                refresh();
            });

            // 掲示場所の追加・削除後も評価
            const observer = new MutationObserver(refresh);
            observer.observe(tbody, { childList: true, subtree: true });

            // 初期評価
            refresh();


            // --- イベント: ヘッダチェック → 全行ON/OFF ---
            if (chkAll) {
                chkAll.addEventListener('change', () => {
                    const isOn = chkAll.checked;
                    getRowChecks().forEach(c => c.checked = isOn);
                    // ここでsyncHeaderCheckbox()は不要（chkAll自身がすでにその状態）
                    refresh(); // ★追加
                });
            }

            // --- イベント: 行の削除ボタン ---
            tbody.addEventListener('click', (e) => {
                const btn = e.target.closest('.btnRemoveSpot');
                if (!btn) return;

                const rows = tbody.querySelectorAll('tr.spot-row');
                if (rows.length <= 1) {
                    alert('掲示場所は最低1件必要です。');
                    return;
                }

                btn.closest('tr').remove();
                reindex();
                refresh(); // ★追加
            });

            // --- イベント: 行の必須チェックが変わったらヘッダ同期 ---
            tbody.addEventListener('change', (e) => {
                if (e.target && e.target.matches('input.form-check-input[type="checkbox"]')) {
                    syncHeaderCheckbox();
                }
            });

            // --- イベント: 追加ボタン ---
            if (btnAdd) {
                btnAdd.addEventListener('click', () => addRow(""));
            }

            // 初期状態の保険：0件なら1行作る
            if (tbody.querySelectorAll('tr.spot-row').length === 0) {
                addRow("");
            } else {
                reindex();
            }
        })();
    </script>
}
